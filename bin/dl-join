#!/bin/bash

set -e

RES_URL='http://docklet.unias.org'

function log_msg {
	TYPE=$1 && shift && COLOR=35
	[[ "${TYPE}" == "INFO" ]] && COLOR=34
	[[ "${TYPE}" == "WARN" ]] && COLOR=33
	[[ "${TYPE}" == "ERROR" ]] && COLOR=31
	echo -e "\033[${COLOR}m[${TYPE}] $@\033[0m" > /dev/stderr
	[[ "${TYPE}" == "ERROR" ]] && exit 1
	return 0
}

log_msg "INFO" "Docklet Cluster for Ubuntu distribution x86_64."

[[ "`uname -a | grep x86_64`" == "" ]] && log_msg "ERROR" "Only x86_64-arch is supported."

[[ "`whoami`" != "root" ]] && log_msg "ERROR" "Root previledge required!"

. /etc/docklet/docklet.conf

if [[ "`which etcd 2>/dev/null`" == "" ]]; then
	apt-get install -y cgroup-lite lxc ethtool bridge-utils libapparmor1 nmap curl sshfs netcat-openbsd net-tools openssh-server openvswitch-switch
	curl -L "${RES_URL}/docklet-bin-latest.tar.gz" > /tmp/docklet-bin.tgz
	
	cd /usr/local/bin
	tar xvf /tmp/docklet-bin.tgz
	rm -f /tmp/docklet-bin.tgz
fi

if [[ "`cat /proc/cmdline | grep cgroup`" == "" ]]; then
	if [[ "`cat /etc/default/grub | grep cgroup`" == "" ]]; then
		echo 'GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"' >> /etc/default/grub
		update-grub > /dev/stderr
	fi
	log_msg "ERROR" "Memory limit will be enabled after your next reboot, you should reboot system and run dl-join again. Otherwise memory limit will not work."
fi

ip link delete lxcbr0 >/dev/null 2>&1 || true

if [[ "${MACHINE_CIDR}" == "172.31.0.1/32" ]]; then
	log_msg "WARN" "Setting up for localhost."
	ip link delete dev ethlo 2>/dev/null || true
	brctl addbr ethlo
	ip addr add 172.31.0.1/16 dev ethlo
	ip link set dev ethlo up
	
	if [[ ! -e "/root/.ssh/id_rsa" ]] && [[ ! -e "/root/.ssh/authorized_keys" ]]; then
		mv /root/.ssh/id_rsa /root/.ssh/id_rsa.bak 2>/dev/null || true
		mv /root/.ssh/id_rsa.pub /root/.ssh/id_rsa.pub.bak 2>/dev/null || true
		mv /root/.ssh/authorized_keys /root/.ssh/authorized_keys.bak 2>/dev/null || true
		
		echo -e '\n' | ssh-keygen -t rsa -P '' >/dev/null 2>&1
		mv /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys
	fi
	
	iptables -t nat -D POSTROUTING -s 172.31.0.0/16 ! -o docker0 -j MASQUERADE >/dev/null 2>&1 || true
	iptables -t nat -A POSTROUTING -s 172.31.0.0/16 ! -o docker0 -j MASQUERADE
	
	ssh root@0.0.0.0 true
fi

log_msg "INFO" "Finish setting up."

UNIONS=$(echo -e "`blink ${MACHINE_CIDR}`\n`ip addr | grep inet\  | awk '{print $2}' | awk -F\/ '{print $1}'`" | sort)

for MY_IP in ${UNIONS}; do
	[[ "${PREV_IP}" == "${MY_IP}" ]] && break
	PREV_IP=${MY_IP}
done

log_msg "INFO" "IP of this host is ${MY_IP}."

lxc-stop -n core-service -k 2>/dev/null || true

killall lxc-start >/dev/null 2>&1 || true
killall etcd >/dev/null 2>&1 || true

log_msg "INFO" "Make sure all resources are released .."

mkdir -p ${NFS_PREFIX}/global ${NFS_PREFIX}/local

mkdir -p ${NFS_PREFIX}/local/volumes/ ${NFS_PREFIX}/local/mounts/

if [[ "${NFS_MOUNT_CMD}" != "" ]]; then
	if mountpoint ${NFS_PREFIX}/global -q; then
		log_msg "INFO" "Remounting Commong NFS ${NFS_PREFIX}/global .."
		umount -l ${NFS_PREFIX}/global
	fi
	`${NFS_MOUNT_CMD}`
fi

mkdir -p ${NFS_PREFIX}/global/users ${NFS_PREFIX}/global/images

HOSTS="`blink ${MACHINE_CIDR}`"
PEERS=""
for MIP in $HOSTS; do
        if nc -q 0 $MIP 7001 </dev/null >/dev/null 2>&1; then
                PEERS="--peers $MIP:7001"
		log_msg "INFO" "Machine discovery: ${MIP}"
                break
        fi
done

if [[ ! -e "${NFS_PREFIX}/local/filesystem" ]]; then
	mkdir -p ${NFS_PREFIX}/local/filesystem ${NFS_PREFIX}/global/images
	cd ${NFS_PREFIX}/local/filesystem
	touch .dockerenv .dockerinit
	tar czvf ${NFS_PREFIX}/global/images/pub_root_base.tgz ./
	curl -L "${RES_URL}/filesystem.tgz" > /tmp/filesystem.tgz
	tar xvf /tmp/filesystem.tgz
	rm -f /tmp/filesystem.tgz
	cd ${NFS_PREFIX}/local/filesystem/dev
	
	rm random urandom tty tty1 null ptmx zero null console -f
	mknod -m 622 console c 5 1
	mknod -m 666 null c 1 3
	mknod -m 666 zero c 1 5
	mknod -m 666 ptmx c 5 2
	mknod -m 666 tty c 5 0
	mknod -m 444 random c 1 8
	mknod -m 444 urandom c 1 9
fi

cd ${NFS_PREFIX}/global
echo '["HOME=/root","PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin","TERM=xterm"]' > ./dockerenv

if [[ "${PEERS}" == "" ]]; then
	rm -rf ./etcd
	# prepare pub_root_base
fi

log_msg "WARN" "etcd -peer-addr ${MY_IP}:7001 -addr ${MY_IP}:4001 -data-dir etcd/${MY_IP} -name ${MY_IP} ${PEERS}"
etcd -peer-addr ${MY_IP}:7001 -addr ${MY_IP}:4001 -data-dir etcd/${MY_IP} -name ${MY_IP} ${PEERS} >/dev/null 2>&1 &

log_msg "INFO" "Waiting etcd to get ready .." && sleep 2

domainname $(echo ${NIS_SERVER} | awk '{print $2}') >/dev/null 2>&1

iptables -F
iptables -t nat -F
iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -j MASQUERADE

ip link set ovs-link down 2>/dev/null || true
ip link set ovs-bridge down 2>/dev/null || true

ovs-vsctl del-br ovs-link 2>/dev/null || true
ovs-vsctl add-br ovs-link
brctl delbr ovs-bridge 2>/dev/null || true
brctl addbr ovs-bridge

ip addr add 10.0.0.$(echo ${MY_IP} | awk -F\. '{print $NF}')/8 dev ovs-bridge
ip link set dev ovs-bridge up
brctl addif ovs-bridge ovs-link

LIVE_HOSTS="$(KEY='/_etcd/machines' etcdemu ls | awk -F\/ '{print $NF}')" >/dev/null 2>&1

for HOST in ${LIVE_HOSTS}; do
        [[ "${HOST}" == "${MY_IP}" ]] && continue

        ovs-vsctl add-port ovs-link gre-${HOST} -- set interface gre-${HOST} type=gre options:remote_ip=${HOST}
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${HOST} ovs-vsctl add-port ovs-link gre-${MY_IP} -- set interface gre-${MY_IP} type=gre options:remote_ip=${MY_IP} || true
	break
done

log_msg "INFO" "Finish all initialization .."

while true; do
	HOST=${MY_IP} docklet-watchdog
	sleep 5
done

false

