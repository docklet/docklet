#!/usr/bin/env python

from gevent import monkey
monkey.patch_all()

from flask import Flask, request
from werkzeug.exceptions import BadRequest

import gevent
from gevent.socket import wait_read, wait_write
from gevent.select import select
from gevent.event import Event

import paramiko, socket, json
from paramiko import PasswordRequiredException
from paramiko.dsskey import DSSKey
from paramiko.rsakey import RSAKey
from paramiko.ssh_exception import SSHException

from StringIO import StringIO

class WSSHBridge(object):
	""" WebSocket to SSH Bridge Server """

	def __init__(self, websocket):
		""" Initialize a WSSH Bridge

		The websocket must be the one created by gevent-websocket
		"""
		self._websocket = websocket
		self._ssh = paramiko.SSHClient()
		self._ssh.set_missing_host_key_policy(
			paramiko.AutoAddPolicy())
		self._tasks = []

	def _load_private_key(self, private_key, passphrase=None):
		""" Load a SSH private key (DSA or RSA) from a string

		The private key may be encrypted. In that case, a passphrase
		must be supplied.
		"""
		key = None
		last_exception = None
		for pkey_class in (RSAKey, DSSKey):
			try:
				key = pkey_class.from_private_key(StringIO(private_key),
					passphrase)
			except PasswordRequiredException as e:
				# The key file is encrypted and no passphrase was provided.
				# There's no point to continue trying
				raise
			except SSHException as e:
				last_exception = e
				continue
			else:
				break
		if key is None and last_exception:
			raise last_exception
		return key

	def open(self, hostname, port=22, username=None, password=None,
					private_key=None, key_passphrase=None,
					allow_agent=False, timeout=None):
		""" Open a connection to a remote SSH server

		In order to connect, either one of these credentials must be
		supplied:
			* Password
				Password-based authentication
			* Private Key
				Authenticate using SSH Keys.
				If the private key is encrypted, it will attempt to
				load it using the passphrase
			* Agent
				Authenticate using the *local* SSH agent. This is the
				one running alongside wsshd on the server side.
		"""
		try:
			pkey = None
			if private_key:
				pkey = self._load_private_key(private_key, key_passphrase)
			self._ssh.connect(
				hostname=hostname,
				port=port,
				username=username,
				password=password,
				pkey=pkey,
				timeout=timeout,
				allow_agent=allow_agent,
				look_for_keys=False)
		except socket.gaierror as e:
			self._websocket.send(json.dumps({'error':
				'Could not resolve hostname {0}: {1}'.format(
					hostname, e.args[1])}))
			raise
		except Exception as e:
			self._websocket.send(json.dumps({'error': e.message or str(e)}))
			raise

	def _forward_inbound(self, channel):
		""" Forward inbound traffic (websockets -> ssh) """
		try:
			while True:
				data = self._websocket.receive()
				if not data:
					return
				data = json.loads(str(data))
				if 'resize' in data:
					channel.resize_pty(
						data['resize'].get('width', 80),
						data['resize'].get('height', 24))
				if 'data' in data:
					channel.send(data['data'])
		finally:
			self.close()

	def _forward_outbound(self, channel):
		""" Forward outbound traffic (ssh -> websockets) """
		try:
			while True:
				wait_read(channel.fileno())
				data = channel.recv(1024)
				if not len(data):
					return
				self._websocket.send(json.dumps({'data': data}))
		finally:
			self.close()

	def _forward_heartbeat(self, channel):
		try:
			while True:
				self._websocket.send(json.dumps({'heartbeat': True}))
				time.sleep(10)
		finally:
			self.close()

	def _bridge(self, channel):
		""" Full-duplex bridge between a websocket and a SSH channel """
		channel.setblocking(False)
		channel.settimeout(0.0)
		self._tasks = [
			gevent.spawn(self._forward_inbound, channel),
			gevent.spawn(self._forward_outbound, channel),
			gevent.spawn(self._forward_heartbeat, channel)
		]
		gevent.joinall(self._tasks)

	def close(self):
		""" Terminate a bridge session """
		gevent.killall(self._tasks, block=True)
		self._tasks = []
		self._ssh.close()

	def execute(self, command, term='xterm'):
		""" Execute a command on the remote server

		This method will forward traffic from the websocket to the SSH server
		and the other way around.

		You must connect to a SSH server using ssh_connect()
		prior to starting the session.
		"""
		transport = self._ssh.get_transport()
		channel = transport.open_session()
		channel.get_pty(term)
		channel.exec_command(command)
		self._bridge(channel)
		channel.close()

	def shell(self, term='xterm'):
		""" Start an interactive shell session

		This method invokes a shell on the remote SSH server and proxies
		traffic to/from both peers.

		You must connect to a SSH server using ssh_connect()
		prior to starting the session.
		"""
		channel = self._ssh.invoke_shell(term)
		self._bridge(channel)
		channel.close()

app = Flask(__name__)

@app.route('/wssh/<hostname>/<username>')
def connect(hostname, username):
	app.logger.debug('{remote} -> {username}@{hostname}: {command}'.format(
			remote=request.remote_addr,
			username=username,
			hostname=hostname,
			command=request.args['run'] if 'run' in request.args else
				'[interactive shell]'
		))

	# Abort if this is not a websocket request
	if not request.environ.get('wsgi.websocket'):
		app.logger.error('Abort: Request is not WebSocket upgradable')
		raise BadRequest()

	bridge = WSSHBridge(request.environ['wsgi.websocket'])
	try:
		bridge.open(
			hostname=hostname,
			username=username,
			password=request.args.get('password'),
			port=int(request.args.get('port')),
			private_key=request.args.get('private_key'),
			key_passphrase=request.args.get('key_passphrase'),
			allow_agent=app.config.get('WSSH_ALLOW_SSH_AGENT', False))
	except Exception as e:
		app.logger.exception('Error while connecting to {0}: {1}'.format(
			hostname, e.message))
		request.environ['wsgi.websocket'].close()
		return str()
	if 'run' in request.args:
		bridge.execute(request.args.get('run'))
	else:
		bridge.shell()

	request.environ['wsgi.websocket'].close()
	return str()


if __name__ == '__main__':
	import argparse
	from gevent.pywsgi import WSGIServer
	from geventwebsocket.handler import WebSocketHandler
	from jinja2 import FileSystemLoader
	import os

	parser = argparse.ArgumentParser(description='wsshd - SSH Over WebSockets Daemon')

	parser.add_argument('--port', '-p', type=int, default=5000)

	parser.add_argument('--host', '-H', default='0.0.0.0')

	parser.add_argument('--allow-agent', '-A', action='store_true', default=False)

	args = parser.parse_args()

	app.config['WSSH_ALLOW_SSH_AGENT'] = args.allow_agent

	app.debug = True
	http_server = WSGIServer((args.host, args.port), app, log=None, handler_class=WebSocketHandler)
	
	try:
		http_server.serve_forever()
	except KeyboardInterrupt:
		pass
